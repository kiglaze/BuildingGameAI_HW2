#include "SpriteCollection.h"
#include "Sprite.h"

void SpriteCollection::addSprite(Sprite* sprite) {
    sprites.push_back(sprite);
}

// Remove the specified sprite.
// This removeSprites code was generated by ChatGPT.
void SpriteCollection::removeSprite(Sprite* sprite) {
    auto it = std::find(sprites.begin(), sprites.end(), sprite);
    if (it != sprites.end()) {
        delete *it; // Delete the sprite
        sprites.erase(it); // Remove the pointer from the collection
    }
}

// Draw all the sprites to the window.
void SpriteCollection::drawAll(sf::RenderWindow& window) {
    for (auto& sprite : sprites) {
        if (sprite != nullptr) {
            sprite->draw(window);
        }
    }
}

// Return the count of all the sprites.
std::size_t SpriteCollection::getSpriteCount() {
    return sprites.size();
}

// Add a new sprite to the starting position.
void SpriteCollection::addStartingSprite(std::string textureFilePath, int isLeader) {
    Sprite* spriteA = new Sprite(textureFilePath, 25.f, 25.f, 0, sf::Vector2f(0, 0), 0, isLeader);
    addSprite(spriteA);
}

// Get all the pointers to sprites.
const std::vector<Sprite*>& SpriteCollection::getSprites() const {
    return sprites;
}

sf::Vector2f SpriteCollection::getCOMPosition() {
    std::vector<Sprite*> allSprites = getSprites();
    int allSpritesCount = getSpriteCount();
    float sumXPosVal = 0;
    float sumYPosVal = 0;
    for (Sprite* sprite : allSprites) {
        sf::Vector2f spritePosVect = sprite->getPosition();
        sumXPosVal += spritePosVect.x;
        sumYPosVal += spritePosVect.y;
    }
    return sf::Vector2f((sumXPosVal/allSpritesCount), (sumYPosVal/allSpritesCount));
}
sf::Vector2f SpriteCollection::getCOMVelocityVector() {
    std::vector<Sprite*> allSprites = getSprites();
    int allSpritesCount = getSpriteCount();
    float sumXVelVal = 0;
    float sumYVelVal = 0;
    for (Sprite* sprite : allSprites) {
        sf::Vector2f spriteVelVect = sprite->getVelocityVector();
        sumXVelVal += spriteVelVect.x;
        sumYVelVal += spriteVelVect.y;
    }
    return sf::Vector2f((sumXVelVal/allSpritesCount), (sumYVelVal/allSpritesCount));
}

// Delete all sprites that are marked for deletion.
void SpriteCollection::deleteMarkedSprites() {
    const std::vector<Sprite*>& allSprites = getSprites();

    for (Sprite* sprite : allSprites) {
        if (sprite != nullptr && sprite->shouldBeDeleted() == 1) {
            removeSprite(sprite);
        }
    }
}
